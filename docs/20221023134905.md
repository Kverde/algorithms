---
page_type: algorithm
---

# Сортировка выбором (Selection sort)

Во время сортировки выбором массив делится на две части: отсортированную и неотсортированную. Отсортированная часть, во время первой итерации алгоритма, состоит из нуля элементов, а неотсортированная составляет весь массив. С каждой итераций отсортированная часть увеличивается на один элемент, а неотсортированная уменьшается.

![](images/selection_sort01.svg)

Во время каждой итерации алгоритм ищет максимальный или минимальный элемент в неотсортированной части массива, а затем добавляет его к отсортированной части. Точнее говоря, ближайший к отсортированной части массива элемент, заменяется на подходящий из остальной части массива.

![](images/selection_sort02.svg)


## Псевдокод

```
алгоритм сортировка_выбором(массив)
начало
  для каждого индекса в массиве
    находим минимальным элемент с индексом большим или равным текущему
    меняем местами элемент с текущим индексом и найденный элемент
конец
```

Поиск минимального элемента по сути является алгоритмом [линейного поиска](20221023135032.md).

## Реализация на Python

Перемещение элементов из неотсортированной части в отсортированную производится с помощью цикла. Цикл должен пройти от первого до предпоследнего элемента. Последний элемент проверять не требуется, так как после сортировки остальных элементов он уже окажется на своем месте.

```python
def selection_sort(lst):
    for i in range(0, len(lst) - 1):
```

Таким образом сразу решается проблема с граничными случаями: когда массив пустой или из одного элемента цикл выполнятся не будет.

На каждой итерации внешнего цикла нужно найти минимальный или максимальный элемент в остальной части массива — применить [алгоритм линейного поиска](20221023135032.md), следовательно понадобится либо вызов функции либо просто второй цикл.

```python
def selection_sort(lst):
    for i in range(0, len(lst) - 1):
        for j in range(i + 1, len(lst)):
            if lst[j] < lst[i]:
                lst[i], lst[j] = lst[j], lst[i]
    return lst
```

## Требования

Для эффективного применения сортировки выбором требуется коллекция с [произвольным доступом](20221108225121.md).

## Анализ сложности

Сложность сортировки выбором равна $\mathcal{O}(n^2)$. Сортировка выбором содержит типичную конструкцию для такой сложности — вложенные циклы. Внешний цикл выполняется $n - 1$ раз. Количество выполнений внутреннего цикла постепенно уменьшается от $n$ до $1$, что в среднем даёт $0.5n$. Таким образом количество операций равно

$$
(n - 1) * 0.5n = 0.5n^2 - 0.5n
$$
что сокращается до $\mathcal{O}(n^2)$.

Сортировка выбором не требует дополнительной памяти при увеличении входного массива, поэтому сложность по памяти равна $\mathcal{O(1)}$.

## Ссылки

- [Грокаем алгоритмы. Адитья Бхаргава. Питер. 2018](BhargavaGrokaemAlgoritmy2018.md). Глава 2. Сортировка выбором. Сортировка выбором


## Ссылки на эту заметку




<p v-pre style="text-align: right">
  <a href="https://github.com/Kverde/algorithms/blob/main/source/20221023134905.md" target="_blank">
  Эта заметка на GitHub
  </a>
</p>



<p v-pre style="text-align: right">
  <a href="https://discourse.comtext.space/new-topic?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%BE%D0%BC%20%28Selection%20sort%29&body=&category=algorithm" target="_blank">
  Обсудить на форуме
  </a>
</p>
