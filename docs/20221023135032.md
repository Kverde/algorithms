---
page_type: algorithm
---

# Линейный поиск (Linear search)

Линейный поиск — алгоритм поиска в неупорядоченном [массиве](20221025215309.md) или [связанном списке](20221024232535.md).

Алгоритм может использоваться для:

* Проверки наличия элемента в коллекции
* Поиска индекса элемента в коллекции
* Поиска элемента в коллекции по определённому признаку

## Псевдокод

Алгоритм линейного поиска предельно прост: последовательно перебираем элементы коллекции пока не найден нужный элемент. Если элемент не найден, то возвращаем признак его отсутствия. Так как индексом элемента может быть только [натуральное число](20221108225922.md), то, обычно, в качестве признака отсутствия элемента в коллекции, функция линейного поиска возвращает число -1.

```
алгоритм линейный_поиск(последовательность, искомый_элемент)
начало
  для каждого элемента в последовательности
    если элемент равен искомомый_элемент
      то возвращаем индекс элемента и завершаем алгоритм
  
  возвращаем -1
конец
```

## Пример на Python

```python
def linear_search(lst, element):
    for i, item in enumerate(lst):
        if item == element:
            return i

    return -1
```
## Требования

Для линейного поиска нет особых требований к входным данным. [Произвольный доступ](20221108225121.md) для входной коллекции не обязателен, сортировка тоже не требуется.

## Варианты алгоритма

Для определения искомого элемента может использоваться не только простое сравнение но и любое другое условие, например, вместе искомого элемента в функцию линейного поиска может передаваться функция-предикат.

Линейный поиск может искать больше одного элемента, в этом случае лучше использовать `filter`.

Линейный поиск может применяться для поиска минимального или максимального элемента.

## Анализ сложности

Алгоритм выполняет количество действие пропорционально размеру входной коллекции поэтому временная сложность равна $\mathcal{O(n)}$.

Потребление памяти не зависит от размера входной коллекции — используется только несколько локальных переменных, поэтому потребление памяти равно $\mathcal{O(1)}$.

## Связанные алгоритмы

Если массив отсортирован то более эффективно использовать [бинарный поиск](20221025215226.md).


## Ссылки на эту заметку

* [Бинарный поиск (Binary search)](20221025215226.md)
* [Инвариант](20221123224315.md)
* [Использование барьера для упрощения условия перебора списка](20221124190034.md)
* [Сортировка выбором (Selection sort)](20221023134905.md)


<p v-pre style="text-align: right">
  <a href="https://github.com/Kverde/algorithms/blob/main/source/20221023135032.md" target="_blank">
  Эта заметка на GitHub
  </a>
</p>



<p v-pre style="text-align: right">
  <a href="https://discourse.comtext.space/new-topic?title=%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D1%8B%D0%B9%20%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%20%28Linear%20search%29&body=&category=algorithm" target="_blank">
  Обсудить на форуме
  </a>
</p>
