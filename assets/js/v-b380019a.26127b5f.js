"use strict";(self.webpackChunkalgorithms_way23_ru=self.webpackChunkalgorithms_way23_ru||[]).push([[764],{3237:(n,a,s)=>{s.r(a),s.d(a,{data:()=>t});const t=JSON.parse('{"key":"v-b380019a","path":"/20221027000407.html","title":"Стек вызовов (Call stack)","lang":"ru-RU","frontmatter":{"page_type":"concept"},"excerpt":"","headers":[{"level":2,"title":"Ссылки","slug":"ссылки","link":"#ссылки","children":[]},{"level":2,"title":"Ссылки на эту заметку","slug":"ссылки-на-эту-заметку","link":"#ссылки-на-эту-заметку","children":[]}],"git":{"updatedTime":1669660493000},"filePathRelative":"20221027000407.md"}')},8228:(n,a,s)=>{s.r(a),s.d(a,{default:()=>h});var t=s(6252);const e=(0,t._)("h1",{id:"стек-вызовов-call-stack",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#стек-вызовов-call-stack","aria-hidden":"true"},"#"),(0,t.Uk)(" Стек вызовов (Call stack)")],-1),l=(0,t._)("p",null,"Стек вызовов — конструкция, образующаяся в памяти когда функции вызывают друг друга.",-1),p=(0,t.uE)('<p>Рассмотрим функцию <code>print_vector_length</code> для печати длины вектора который начинается в начале координат. На вход функции <code>print_vector_length</code> поступают координаты вектора, вычисляется длина вектора и печатается на экран. Для вычисления длины используется вторая функция <code>calc_distance</code> которая вычисляет расстояние между двумя точками.</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> math <span class="token keyword">import</span> sqrt\n\n\n<span class="token keyword">def</span> <span class="token function">calc_distance</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    <span class="token keyword">return</span> sqrt<span class="token punctuation">(</span><span class="token punctuation">(</span>x1 <span class="token operator">-</span> x2<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>y1 <span class="token operator">-</span> y2<span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>\n\n\n<span class="token keyword">def</span> <span class="token function">print_vector_length</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    length <span class="token operator">=</span> calc_distance<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token keyword">print</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span>\n\n\nprint_vector_length<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="images/call-stack01.svg" alt=""></p><p>Аналогичная запись на стеке создается и при вызове функции <code>sqrt</code> внутри <code>calc_distance</code>, <strong>каждый вызов функции</strong> повышает глубину стека вызовов.</p>',4),c=(0,t._)("strong",null,"запись на стеке соответствует не функции, а вызову функции",-1),o=(0,t._)("p",null,"Чем больше глубина вложенности функций, тем больше будет расти стек вызовов и тем больше будут затраты памяти. Следовательно, глубина вызовов функции ограничена памятью.",-1),i=(0,t._)("h2",{id:"ссылки",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#ссылки","aria-hidden":"true"},"#"),(0,t.Uk)(" Ссылки")],-1),u=(0,t._)("h2",{id:"ссылки-на-эту-заметку",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#ссылки-на-эту-заметку","aria-hidden":"true"},"#"),(0,t.Uk)(" Ссылки на эту заметку")],-1),r=(0,t._)("p",{style:{"text-align":"right"}},[(0,t._)("a",{href:"https://github.com/Kverde/algorithms/blob/main/source/20221027000407.md",target:"_blank"}," Эта заметка на GitHub ")],-1),d=(0,t._)("p",{style:{"text-align":"right"}},[(0,t._)("a",{href:"https://discourse.comtext.space/new-topic?title=%D0%A1%D1%82%D0%B5%D0%BA%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2%20%28Call%20stack%29&body=&category=algorithm",target:"_blank"}," Обсудить на форуме ")],-1),k={},h=(0,s(3744).Z)(k,[["render",function(n,a){const s=(0,t.up)("RouterLink");return(0,t.wg)(),(0,t.iD)("div",null,[e,l,(0,t._)("p",null,[(0,t.Uk)("Во время вызова функции для неё выделяется память (для локальных переменных, аргументов и других объектов), если одна функция вызывает другую функцию, то снова происходит выделение памяти под новый вызов, в то же время, память под первую функцию остаётся занята, до возврата в неё управления. Таким образом стек вызовов состоит из записей или элементов стека вызовов однозначно соответствующих вызовам функций. Стек вызовов работает по принципу "),(0,t.Wm)(s,{to:"/20221022204419.html"},{default:(0,t.w5)((()=>[(0,t.Uk)("LIFO")])),_:1}),(0,t.Uk)(" — последняя вызванная функция находится на вершине стека и удаляется из него при завершении.")]),p,(0,t._)("p",null,[(0,t.Uk)("Функция, по отношению к записи на стеке вызовов, является шаблоном вычислительного процесса, а запись на стеке вызовов — это данные этого процесса. Каждый вызов функции порождает вычислительный процесс и выделяет для него запись на стеке вызовов. Если "),(0,t.Wm)(s,{to:"/20221027000223.html"},{default:(0,t.w5)((()=>[(0,t.Uk)("функция вызывает саму себя")])),_:1}),(0,t.Uk)(", то образуется несколько независимых записей на стеке вызовов, так как "),c,(0,t.Uk)(".")]),o,i,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Wm)(s,{to:"/BhargavaGrokaemAlgoritmy2018.html"},{default:(0,t.w5)((()=>[(0,t.Uk)("Грокаем алгоритмы. Адитья Бхаргава. Питер. 2018")])),_:1}),(0,t.Uk)(". Глава 3. Рекурсия. Стек. Стек вызовов")])]),u,(0,t._)("ul",null,[(0,t._)("li",null,[(0,t.Wm)(s,{to:"/20221027000223.html"},{default:(0,t.w5)((()=>[(0,t.Uk)("Рекурсия (Recursion)")])),_:1})])]),r,d])}]])}}]);